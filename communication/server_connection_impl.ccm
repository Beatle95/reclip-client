module;

#include <QByteArray>
#include <QObject>
#include <QSslSocket>
#include <cassert>
#include <cstdint>
#include <span>

#include "base/log.h"

export module communication.connection_impl;

export import communication.server_connection;

import base.byte_swap;
import communication.message_types;
import communication.message_reassembler;

namespace reclip {

// This class abstracts away connection and communication with server.
export class ServerConnectionImpl : public QObject, public ServerConnection {
 public:
  explicit ServerConnectionImpl(ServerConnection::Delegate& delegate, const QString& ip,
                                quint16 port);
  ~ServerConnectionImpl() override;

  // ServerConnection overrides
  void Connect() override;
  void Disconnect() override;
  bool SendMessage(uint64_t id, ClientMessageType type, const QByteArray& data) override;

 private:
  void OnConnected();
  void OnEncrypted();
  void OnDisconnected();
  void OnError(QAbstractSocket::SocketError err);
  void OnSslError(const QList<QSslError>& errors);
  void OnReadyRead();

 private:
  enum class State { kDisconnected, kConnected, kEncrypted };

  QString ip_;
  quint16 port_;

  QSslSocket socket_;
  MessageReassembler reassembler_;
  ServerConnection::Delegate* delegate_;

  // This field will help us to distinguish between errors upon connection and
  // errors upon communication process.
  State state_ = State::kDisconnected;
};

namespace {

struct NetworkHeader {
  uint64_t id;     // Unique id of the message.
  uint16_t type;   // Value of MessageType enum.
  char unused[6];  // Reserved.
};
static_assert(sizeof(NetworkHeader) == 16);

struct NetworkHeaderWithLength {
  uint64_t len;
  NetworkHeader header;
};
static_assert(sizeof(NetworkHeaderWithLength) == 24);

template <typename T>
bool FromRawBytes(std::span<const char> data, T& result) {
  static_assert(std::is_trivially_copy_constructible_v<T>);
  if (data.size() < sizeof(result)) {
    return false;
  }
  std::memcpy(&result, data.data(), sizeof(result));
  return true;
}

bool ParseNetworkHeader(const QByteArray& data, NetworkHeader& header) {
  if (!FromRawBytes(data, header)) {
    return false;
  }
  header.id = ntoh(header.id);
  header.type = ntoh(header.type);
  return true;
}

}  // namespace

ServerConnectionImpl::ServerConnectionImpl(ServerConnection::Delegate& delegate, const QString& ip,
                                           quint16 port)
    : ip_(ip), port_(port), delegate_(&delegate) {
  socket_.setProtocol(QSsl::SslProtocol::TlsV1_2OrLater);

  // TODO: Probably we still will have to add self-signed certs here.
  // auto serverCerts = QSslCertificate::fromPath("/app_data/cert.pem");
  // if (!serverCerts.empty()) {
  //   LOG(INFO) << "Server certificate is added from app data";
  //   auto conf = QSslConfiguration{};
  //   conf.addCaCertificates(serverCerts);
  //   socket_.setSslConfiguration(conf);
  // }
  // There was a problem observed on macOS, if 'securetransport' backend is used, we can't establish
  // connection even we add server cert via addCaCertificates. To fix that we have to ignore
  // Untrusted certificate error or set certifiacate in the system.

  connect(&socket_, &QSslSocket::connected, this, &ServerConnectionImpl::OnConnected);
  connect(&socket_, &QSslSocket::encrypted, this, &ServerConnectionImpl::OnEncrypted);
  connect(&socket_, &QSslSocket::disconnected, this, &ServerConnectionImpl::OnDisconnected);
  connect(&socket_, &QSslSocket::errorOccurred, this, &ServerConnectionImpl::OnError);
  connect(&socket_, &QSslSocket::sslErrors, this, &ServerConnectionImpl::OnSslError);
  connect(&socket_, &QSslSocket::readyRead, this, &ServerConnectionImpl::OnReadyRead);
}

ServerConnectionImpl::~ServerConnectionImpl() { socket_.disconnect(); }

void ServerConnectionImpl::Connect() {
  assert(state_ == State::kDisconnected);
  socket_.connectToHostEncrypted(ip_, port_);
}

void ServerConnectionImpl::Disconnect() { socket_.disconnectFromHost(); }

bool ServerConnectionImpl::SendMessage(uint64_t id, ClientMessageType type,
                                       const QByteArray& data) {
  if (state_ == State::kDisconnected) {
    assert(false && "Sending via disconnected connection");
    return false;
  }

  NetworkHeaderWithLength full_header{
      .len = sizeof(NetworkHeader) + data.size(),
      .header = {.id = id, .type = static_cast<uint16_t>(type), .unused = {}}};
  full_header.len = hton(full_header.len);
  full_header.header.id = hton(full_header.header.id);
  full_header.header.type = hton(full_header.header.type);
  std::memset(full_header.header.unused, 0, sizeof(full_header.header.unused));

  if (socket_.write(reinterpret_cast<const char*>(&full_header), sizeof(full_header)) !=
      sizeof(full_header)) {
    LOG(ERROR) << "Unable to send network header via socket";
    return false;
  }
  if (socket_.write(data) != data.size()) {
    LOG(ERROR) << "Unable to send data via socket";
    return false;
  }
  return true;
}

void ServerConnectionImpl::OnConnected() {
  state_ = State::kConnected;
}

void ServerConnectionImpl::OnEncrypted() {
  state_ = State::kEncrypted;
  reassembler_.Clear();
  delegate_->HandleConnected(true);
}

void ServerConnectionImpl::OnDisconnected() {
  // For our delegate we want to hide encryption, for it only encrypted state will be treated as
  // connected.
  if (state_ == State::kEncrypted) {
    delegate_->HandleDisconnected();
  } else {
    delegate_->HandleConnected(false);
  }
  state_ = State::kDisconnected;
}

void ServerConnectionImpl::OnError(QAbstractSocket::SocketError err) {
  LOG(ERROR) << "ServerConnection connection error occured: " << err;
  if (state_ == State::kDisconnected) {
    delegate_->HandleConnected(false);
  }
}

void ServerConnectionImpl::OnSslError(const QList<QSslError>& errors) {
  QString error_str;
  for (const auto& entry : errors) {
    if (!error_str.isEmpty()) {
      error_str.append("; ");
    }
    error_str.append(entry.errorString() + "; ");
  }
  LOG(ERROR) << "SSL errors: " << (!error_str.isEmpty() ? error_str : QString("unspecified error"));
}

void ServerConnectionImpl::OnReadyRead() {
  if (reassembler_.IsBroken()) {
    // This could happen if we have entered disconnected state, but before disconnection, server has
    // sent some data to us. Just ignore it and wait for disconnection.
    return;
  }

  auto data = socket_.readAll();
  if (!data.isEmpty()) {
    reassembler_.Process(data);
    if (reassembler_.IsBroken()) {
      LOG(ERROR) << "ServerConnection reassembler has entered broken state";
      socket_.disconnectFromHost();
      return;
    }
  }

  while (reassembler_.HasMessage()) {
    auto msg = reassembler_.PopMessage();
    NetworkHeader header;
    if (ParseNetworkHeader(msg, header)) {
      delegate_->HandleReceieved(header.id, static_cast<ServerMessageType>(header.type),
                                 msg.mid(sizeof(NetworkHeader)));
    } else {
      LOG(ERROR) << "Unable to parse network header (size was: " << msg.size() << ")";
    }
  }
}

}  // namespace reclip
