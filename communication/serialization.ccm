module;

#include <QByteArray>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QString>
#include <QVersionNumber>
#include <cassert>
#include <cstdint>
#include <deque>
#include <optional>
#include <string>
#include <vector>

export module communication.serialization;

import core.host_types;

export namespace reclip {

struct Version {
  uint32_t major;
  uint32_t minor;
  uint32_t patch;
};

struct IntroductionResponse {
  Version server_version;
  QString error;
  bool success;
};

struct SyncResponse {
  HostData this_host_data;
  std::vector<HostData> hosts_data;
};

struct TextUpdateResponse {
  HostPublicId id;
  std::string text;
};

QByteArray SerializeHostSyncRequest(HostPublicId id);
QByteArray SerializeTextUpdate(const std::string& text);
QByteArray SerializeHostSync(const HostData& data);

IntroductionResponse ParseIntroductionResponse(const QByteArray& data);
std::optional<SyncResponse> ParseSyncResponse(const QByteArray& data);
std::optional<HostPublicId> ParseHostId(const QByteArray& data);
std::optional<HostData> ParseHostData(const QByteArray& data);
std::optional<TextUpdateResponse> ParseNewText(const QByteArray& data);

class SerializationTestHelper {
 public:
  SerializationTestHelper();
  virtual ~SerializationTestHelper();

  virtual IntroductionResponse ParseIntroductionResponse(
      const QByteArray& data) = 0;
  virtual std::optional<SyncResponse> ParseSyncResponse(
      const QByteArray& data) = 0;
  virtual std::optional<HostPublicId> ParseHostId(const QByteArray& data) = 0;
  virtual std::optional<HostData> ParseHostData(const QByteArray& data) = 0;
  virtual std::optional<TextUpdateResponse> ParseNewText(
      const QByteArray& data) = 0;
};

}  // export namespace reclip

namespace reclip {

namespace {

constexpr char kHostIdKey[] = "ClientId";
constexpr char kHostNameKey[] = "ClientName";
constexpr char kWrongServerResponseFormat[] = "wrong server response format";

std::optional<HostData> ParseHost(const QJsonObject& obj) {
  const auto id = obj.find(kHostIdKey);
  if (id == obj.end() || !id->isDouble()) {
    return {};
  }
  const auto name = obj.find(kHostNameKey);
  if (name == obj.end() || !name->isString()) {
    return {};
  }

  const auto text_data = obj.find("TextData");
  if (text_data == obj.end() || !text_data->isArray()) {
    return {};
  }
  std::deque<std::string> text;
  auto text_arr = text_data->toArray();
  for (auto entry : text_arr) {
    if (!entry.isString()) {
      return {};
    }
    text.push_back(entry.toString().toStdString());
  }

  return HostData{
      .id = HostPublicId{id->toInteger()},
      .name = name->toString().toStdString(),
      .data = {.text = std::move(text)},
  };
}

SerializationTestHelper* g_test_helper = nullptr;

}  // namespace

QByteArray SerializeHostSyncRequest(HostPublicId id) {
  QJsonObject root;
  // For now let's ignore possible casting errors.
  root[kHostIdKey] = static_cast<int64_t>(id.ToUnderlying());
  return QJsonDocument(root).toJson(QJsonDocument::Compact);
}

QByteArray SerializeTextUpdate(const std::string& text) {
  QJsonObject root;
  root["Text"] = QString::fromStdString(text);
  return QJsonDocument(root).toJson(QJsonDocument::Compact);
}

QByteArray SerializeHostSync(const HostData& data) {
  QJsonArray text;
  for (const auto& entry : data.data.text) {
    text.push_back(QString::fromStdString(entry));
  }

  QJsonObject root;
  // For now let's ignore possible casting errors.
  root[kHostIdKey] = static_cast<int64_t>(data.id.ToUnderlying());
  root[kHostNameKey] = QString::fromStdString(data.name);
  root["TextData"] = text;

  return QJsonDocument(root).toJson(QJsonDocument::Compact);
}

IntroductionResponse ParseIntroductionResponse(const QByteArray& data) {
  if (g_test_helper) {
    return g_test_helper->ParseIntroductionResponse(data);
  }

  IntroductionResponse result{};
  auto doc = QJsonDocument::fromJson(data);
  if (doc.isEmpty()) {
    result.error = kWrongServerResponseFormat;
    return result;
  }
  auto root = doc.object();
  if (root.isEmpty()) {
    result.error = kWrongServerResponseFormat;
    return result;
  }

  const auto err = root.find("Error");
  if (err != root.end()) {
    result.error = err->toString(kWrongServerResponseFormat);
    return result;
  }
  const auto version_it = root.find("Version");
  if (version_it == root.end() || !version_it->isString()) {
    result.error = kWrongServerResponseFormat;
    return result;
  }

  const auto version = QVersionNumber::fromString(version_it->toString());
  if (version.isNull()) {
    result.error = "unable to parse version string";
    return result;
  }

  result.success = true;
  return result;
}

std::optional<SyncResponse> ParseSyncResponse(const QByteArray& data) {
  if (g_test_helper) {
    return g_test_helper->ParseSyncResponse(data);
  }

  auto doc = QJsonDocument::fromJson(data);
  if (doc.isEmpty()) {
    return {};
  }

  auto root = doc.object();
  if (root.isEmpty()) {
    return {};
  }

  auto this_host_it = root.find("ThisHostData");
  auto hosts_data_it = root.find("OtherData");
  if (this_host_it == root.end() || hosts_data_it == root.end() ||
      !this_host_it->isObject() || !hosts_data_it->isArray()) {
    return {};
  }

  auto this_host = ParseHost(this_host_it->toObject());
  if (!this_host) {
    return {};
  }
  std::vector<HostData> hosts;
  for (auto obj : hosts_data_it->toArray()) {
    if (!obj.isObject()) {
      return {};
    }
    auto host_obj = ParseHost(obj.toObject());
    if (!host_obj) {
      return {};
    }
    hosts.push_back(std::move(*host_obj));
  }

  return SyncResponse{std::move(*this_host), std::move(hosts)};
}

std::optional<HostPublicId> ParseHostId(const QByteArray& data) {
  if (g_test_helper) {
    return g_test_helper->ParseHostId(data);
  }

  auto doc = QJsonDocument::fromJson(data);
  if (doc.isEmpty()) {
    return {};
  }
  auto root = doc.object();
  if (root.isEmpty()) {
    return {};
  }

  const auto id = root.find(kHostIdKey);
  if (id == root.end() || !id->isDouble()) {
    return {};
  }
  return HostPublicId{id->toInteger()};
}

std::optional<HostData> ParseHostData(const QByteArray& data) {
  if (g_test_helper) {
    return g_test_helper->ParseHostData(data);
  }
  auto doc = QJsonDocument::fromJson(data);
  if (doc.isEmpty()) {
    return {};
  }
  return ParseHost(doc.object());
}

std::optional<TextUpdateResponse> ParseNewText(const QByteArray& data) {
  if (g_test_helper) {
    return g_test_helper->ParseNewText(data);
  }

  auto doc = QJsonDocument::fromJson(data);
  if (doc.isEmpty()) {
    return {};
  }
  auto root = doc.object();
  if (root.isEmpty()) {
    return {};
  }

  const auto id = root.find(kHostIdKey);
  if (id == root.end() || !id->isDouble()) {
    return {};
  }
  const auto text = root.find("Text");
  if (text == root.end() || !text->isString()) {
    return {};
  }
  return TextUpdateResponse{.id = HostPublicId{id->toInteger()},
                            .text = text->toString().toStdString()};
}

SerializationTestHelper::SerializationTestHelper() {
  assert(g_test_helper == nullptr);
  g_test_helper = this;
}

SerializationTestHelper::~SerializationTestHelper() {
  assert(g_test_helper == this);
  g_test_helper = nullptr;
}

}  // namespace reclip
