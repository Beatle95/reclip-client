module;

#include <cassert>
#include <chrono>
#include <functional>
#include <memory>
#include <optional>

#include "base/log.h"

export module communication.communication_manager;

import base.observer_helper;
import core.hosts_list_model;
import core.host_model;
import core.host_types;
import communication.connection_info_provider;
import communication.server_impl;

using namespace std::placeholders;

namespace reclip {

export class CommunicationManager : public ServerDelegate, public HostModelObserver {
 public:
  explicit CommunicationManager(HostsListModel& model,
                                std::unique_ptr<ConnectionInfoProvider> conn_info_provider);
  ~CommunicationManager() override = default;
  void DisconnectFromServer(std::function<void(bool)> callback, std::chrono::milliseconds timeout);

  // ServerDelegate overrides:
  ConnectionInfoProvider& GetConnectionInfoProvider() override;
  void OnFullSync(HostData, std::vector<HostData>) override;
  void HostConnected(HostPublicId id) override;
  void HostDisconnected(HostPublicId id) override;
  void HostTextAdded(HostPublicId id, const std::string& text) override;
  void HostSynced(HostData data) override;

  // HostModelObserver overrides:
  void OnTextPushed(const std::string& text) override;
  void OnTextPoped() override {}
  void OnReset() override {}

  Server* GetServerForTesting() { return server_.get(); }

 private:
  void OnHostSynced(std::optional<HostData> data);

  HostsListModel* model_;
  std::unique_ptr<ConnectionInfoProvider> conn_info_provider_;
  std::unique_ptr<Server> server_;
  ScopedObservation<CommunicationManager, HostModel> model_observation_;
};

CommunicationManager::CommunicationManager(
    HostsListModel& model, std::unique_ptr<ConnectionInfoProvider> conn_info_provider)
    : model_(&model), conn_info_provider_(std::move(conn_info_provider)) {
  server_ = std::make_unique<ServerImpl>(*this);
  model_observation_.Reset(*this, model_->GetLocalHost());
}

void CommunicationManager::DisconnectFromServer(std::function<void(bool)> callback,
                                                std::chrono::milliseconds timeout) {
  server_->DisconnectAndStop(std::move(callback), timeout);
}

ConnectionInfoProvider& CommunicationManager::GetConnectionInfoProvider() {
  assert(conn_info_provider_);
  return *conn_info_provider_;
}

void CommunicationManager::OnFullSync(HostData this_host_data, std::vector<HostData> data) {
  auto& local_host = model_->GetLocalHost();
  local_host.SetId(this_host_data.id);
  if (!local_host.AdoptData(std::move(this_host_data.name), std::move(this_host_data.data))) {
    server_->SyncThisHost(local_host.GetData());
  }
  model_->ResetRemoteHostsData(std::move(data));
}

void CommunicationManager::HostConnected(HostPublicId id) {
  if (!model_->GetRemoteHost(id)) {
    server_->RequestHostSync(id, std::bind(&CommunicationManager::OnHostSynced, this, _1));
  }
}

void CommunicationManager::HostDisconnected(HostPublicId id) {
  (void)id;
  // Right now it is not used, but may be used to display state of the host.
}

void CommunicationManager::HostTextAdded(HostPublicId id, const std::string& text) {
  auto* host = model_->GetRemoteHost(id);
  if (host) {
    host->PushText(text);
  } else {
    server_->RequestHostSync(id, std::bind(&CommunicationManager::OnHostSynced, this, _1));
  }
}

void CommunicationManager::HostSynced(HostData data) {
  model_->ResetLocalHostData(std::move(data));
}

void CommunicationManager::OnTextPushed(const std::string& text) {
  server_->AddThisHostText(text);
}

void CommunicationManager::OnHostSynced(std::optional<HostData> data) {
  if (data) {
    HostSynced(std::move(data.value()));
  } else {
    LOG(ERROR) << "Unable to sync host";
  }
}

}  // namespace reclip
