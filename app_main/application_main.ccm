module;

#include <QApplication>
#include <QCommandLineOption>
#include <QCommandLineParser>
#include <QDir>
#include <QFile>
#include <QMenu>
#include <QStandardPaths>
#include <QSystemTrayIcon>
#include <QTimer>
#include <cassert>
#include <chrono>
#include <format>
#include <memory>
#include <stdexcept>

#include "core/clipboard.h"
#include "version.h"

export module app_main.application_main;

import base.constants;
import base.observer_helper;
import base.preferences;
import base.log;
import core.clipboard_model;
import core.shortcut_listener;
import communication.connection_info_provider;
import communication.communication_manager;
import ui.clipboard_controller;

using namespace std::chrono_literals;

namespace reclip {

struct InitArguments {
  QString app_data_dir;
  bool show_ui_on_startup = false;
};

export class ApplicationMain : public QApplication, public ShortcutListener::Delegate {
 public:
  ApplicationMain(int argc, char** argv);
  ~ApplicationMain();

  QDir GetUserDataDir() const { return app_data_dir_; }

  // ShortcutListener overrides
  void HandleShowShortcut() override;

 private:
  InitArguments ParseArgs();
  void InitAppData(const QString& user_overriden_data_dir);
  void PrefInit();
  void LoadStyleSheet();

  void ShowAction(bool);
  void QuitAction(bool);

  QDir app_data_dir_;
  
  std::unique_ptr<Clipboard> clipboard_;
  std::unique_ptr<ClipboardModel> model_;
  std::unique_ptr<CommunicationManager> communication_host_;
  std::unique_ptr<ClipboardController> controller_;
  std::unique_ptr<ShortcutListener> shortcut_listener_;

  std::unique_ptr<QMenu> tray_menu_;
  std::unique_ptr<QSystemTrayIcon> tray_icon_;

  ScopedObservation<ClipboardModel, Clipboard> model_observation_;
  ScopedObservation<ClipboardController, ClipboardModel> controller_observation_;
};

ApplicationMain::ApplicationMain(int argc, char** argv) : QApplication(argc, argv) {
  DLogInfo("Application::Ctor");

  setWindowIcon(QIcon(":icons/app_icon.png"));
  setApplicationName(QString::fromUtf8(kAppName.data(), kAppName.size()));
  setApplicationVersion(QStringLiteral(PROJECT_VER));
  setQuitOnLastWindowClosed(false);

  const auto init_args = ParseArgs();
  InitAppData(init_args.app_data_dir);
  Preferences::Init((app_data_dir_.absolutePath() + "/preferences.json").toStdString());
  auto conn_info_provider = ConnectionInfoProvider::Create(
      (app_data_dir_.absolutePath() + "/server_config.json").toStdString());

  LoadStyleSheet();

  model_ = std::make_unique<ClipboardModel>();
  clipboard_ = Clipboard::Create();
  clipboard_->Start();
  model_observation_.Reset(*model_, *clipboard_);

  communication_host_ =
      std::make_unique<CommunicationManager>(*model_, std::move(conn_info_provider));
  controller_ = std::make_unique<ClipboardController>(model_.get(), clipboard_.get());
  controller_observation_.Reset(*controller_, *model_);
  shortcut_listener_ = std::make_unique<ShortcutListener>(*this);

  if (QSystemTrayIcon::isSystemTrayAvailable()) {
    tray_menu_ = std::make_unique<QMenu>();
    auto* show_action = tray_menu_->addAction("Show");
    auto* quit_action = tray_menu_->addAction("Quit");
    connect(show_action, &QAction::triggered, this, &ApplicationMain::ShowAction);
    connect(quit_action, &QAction::triggered, this, &ApplicationMain::QuitAction);

    tray_icon_ = std::make_unique<QSystemTrayIcon>(QIcon(":icons/tray_icon.png"));
    tray_icon_->setContextMenu(tray_menu_.get());
    tray_icon_->show();
  } else {
    DLogWarning("System tray is not available");
  }

  if (init_args.show_ui_on_startup) {
    QTimer::singleShot(0, [this]() { controller_->ShowUi(); });
  }
}

ApplicationMain::~ApplicationMain() {
  DLogInfo("Application::Dtor");
  clipboard_->Stop();
  Preferences::Deinit((app_data_dir_.absolutePath() + "/preferences.json").toStdString());
}

void ApplicationMain::HandleShowShortcut() { 
  assert(controller_);
  if (controller_->IsUiShown()) {
    controller_->HideUi();
  } else {
    controller_->ShowUi();
  }
}

InitArguments ApplicationMain::ParseArgs() {
  QCommandLineParser parser;
  parser.setApplicationDescription("Reclip allows to synchronize clipboards of multiple devices.");
  parser.addHelpOption();
  parser.addVersionOption();

  QCommandLineOption show_ui_on_startup("show_ui_on_startup",
                                        "Show UI right after application is started.");
  parser.addOption(show_ui_on_startup);
  QCommandLineOption app_data_dir("app-data-dir", "Overrides default user data directrory path.",
                                  "path");
  parser.addOption(app_data_dir);

  parser.process(arguments());
  return {.app_data_dir = parser.value(app_data_dir),
          .show_ui_on_startup = parser.isSet(show_ui_on_startup)};
}

void ApplicationMain::InitAppData(const QString& user_overriden_data_dir) {
  app_data_dir_ = !user_overriden_data_dir.isEmpty()
                      ? user_overriden_data_dir
                      : QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
  if (!app_data_dir_.exists() && !app_data_dir_.mkpath(".")) {
    // TODO: Instead of throwing we want to show some dialog which will help to set up an
    // application.
    throw std::runtime_error(std::format("Failed to create user data directory: '{}'",
                                         app_data_dir_.absolutePath().toStdString()));
  }
  DLogInfo("User data directory: {}", app_data_dir_.absolutePath().toStdString());
}

void ApplicationMain::LoadStyleSheet() {
  QFile file(applicationDirPath() + "/dark.qss");
  if (!file.open(QIODeviceBase::ReadOnly)) {
    LogWarning("Unable to open application stylesheet file: {}",
               (applicationDirPath() + "/dark.qss").toStdString());
    return;
  }
  setStyleSheet(file.readAll());
}

void ApplicationMain::ShowAction(bool) {
  assert(controller_);
  if (!controller_->IsUiShown()) {
    controller_->ShowUi();
  }
}

void ApplicationMain::QuitAction(bool) {
  LogInfo("Quit application triggered from tray icon");
  if (controller_->IsUiShown()) {
    controller_->HideUi();
  }
  communication_host_->DisconnectFromServer(
      [](bool success) {
        if (!success) {
          DLogWarning("Unable to disconnect from server gracefully");
        }
        quit();
      },
      500ms);
}

}  // namespace reclip
