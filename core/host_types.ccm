module;

#include <cassert>
#include <compare>
#include <cstdint>
#include <deque>
#include <format>
#include <ostream>
#include <span>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <vector>

export module core.host_types;

export namespace reclip {

using ClipboardTextContainer = std::deque<std::string>;

// Incapsulates host secret ID. The size of a signature in all constructors is expected to be equal
// to kSecretSize, any other value is considered invalid (exception will be thrown).
class HostSecretId {
 public:
  static constexpr size_t kSecretSize = 512 / 8;

  // Creates simple secret idntified by num.
  static HostSecretId CreateForTesting(uint8_t num);

  HostSecretId() = default;
  explicit HostSecretId(std::span<const uint8_t> signature)
      : signature_(signature.begin(), signature.end()) {
    if (signature.size() != kSecretSize) {
      throw std::runtime_error(std::format("Invalid secret size: {}", signature.size()));
    }
  }
  explicit HostSecretId(std::span<const char> signature)
      : HostSecretId(
            std::span(reinterpret_cast<const uint8_t*>(signature.data()), signature.size())) {}

  bool IsNull() const { return signature_.empty(); }
  std::span<const uint8_t> GetBinary() const { return signature_; }

 private:
  friend std::strong_ordering operator<=>(const HostSecretId& lhs, const HostSecretId rhs);

  std::vector<uint8_t> signature_;
};

class HostPublicId {
 public:
  HostPublicId() = default;
  constexpr HostPublicId(const HostPublicId& other) = default;
  constexpr HostPublicId(HostPublicId&& other) noexcept = default;
  constexpr HostPublicId& operator=(const HostPublicId& other) = default;
  constexpr HostPublicId& operator=(HostPublicId&& other) noexcept = default;

  template <typename T>
    requires std::is_integral_v<T>
  constexpr explicit HostPublicId(T id) : id_(static_cast<uint64_t>(id)) {
    if constexpr (std::is_signed_v<T>) {
      assert(id >= 0);
    }
  }

  constexpr uint64_t ToUnderlying() const { return id_; }

 private:
  uint64_t id_ = 0;
};

// We will create this struct, so later we will populate it with files data.
struct ClipboardData {
  ClipboardTextContainer text;
};

struct HostData {
  HostPublicId id;
  std::string name;
  ClipboardData data;
};

// static
HostSecretId HostSecretId::CreateForTesting(uint8_t num) {
  HostSecretId result;
  result.signature_.resize(kSecretSize);
  result.signature_[0] = num;
  return result;
}

std::strong_ordering operator<=>(const HostSecretId& lhs, const HostSecretId rhs) {
  return lhs.signature_ <=> rhs.signature_;
}

constexpr HostPublicId operator""_pubid(unsigned long long id) { return HostPublicId(id); }

std::ostream& operator<<(std::ostream& os, HostPublicId id) {
  os << id.ToUnderlying();
  return os;
}

bool operator==(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() == rhs.ToUnderlying();
}

bool operator!=(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() != rhs.ToUnderlying();
}

bool operator<(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() < rhs.ToUnderlying();
}

bool operator>(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() > rhs.ToUnderlying();
}

bool operator==(const ClipboardData& lhs, const ClipboardData& rhs) {
  return lhs.text == rhs.text;
}

bool operator!=(const ClipboardData& lhs, const ClipboardData& rhs) {
  return lhs.text != rhs.text;
}

bool operator==(const HostData& lhs, const HostData& rhs) {
  return lhs.id == rhs.id && lhs.name == rhs.name && lhs.data == rhs.data;
}

bool operator!=(const HostData& lhs, const HostData& rhs) {
  return !operator==(lhs, rhs);
}

}  // namespace reclip

export template <>
struct std::formatter<reclip::HostPublicId> {
  auto format(reclip::HostPublicId p, format_context& ctx) {
    return format_to(ctx.out(), "{}", p.ToUnderlying());
  }
};
