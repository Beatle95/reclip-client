module;

#include <cassert>
#include <cstdint>
#include <deque>
#include <format>
#include <ostream>
#include <string>
#include <type_traits>

export module core.host_types;

export namespace reclip {

using HostSecretId = std::string;
using ClipboardTextContainer = std::deque<std::string>;

class HostPublicId {
 public:
  HostPublicId() = default;
  constexpr HostPublicId(const HostPublicId& other) = default;
  constexpr HostPublicId(HostPublicId&& other) noexcept = default;
  constexpr HostPublicId& operator=(const HostPublicId& other) = default;
  constexpr HostPublicId& operator=(HostPublicId&& other) noexcept = default;

  template <typename T>
    requires std::is_integral_v<T>
  constexpr explicit HostPublicId(T id) : id_(static_cast<uint64_t>(id)) {
    if constexpr (std::is_signed_v<T>) {
      assert(id >= 0);
    }
  }

  constexpr uint64_t ToUnderlying() const { return id_; }

 private:
  uint64_t id_ = 0;
};

// We will create this struct, so later we will populate it with files data.
struct ClipboardData {
  ClipboardTextContainer text;
};

struct HostData {
  HostPublicId id;
  std::string name;
  ClipboardData data;
};

constexpr HostPublicId operator""_pubid(unsigned long long id) { return HostPublicId(id); }

std::ostream& operator<<(std::ostream& os, HostPublicId id) {
  os << id.ToUnderlying();
  return os;
}

bool operator==(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() == rhs.ToUnderlying();
}

bool operator!=(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() != rhs.ToUnderlying();
}

bool operator<(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() < rhs.ToUnderlying();
}

bool operator>(HostPublicId lhs, HostPublicId rhs) {
  return lhs.ToUnderlying() > rhs.ToUnderlying();
}

bool operator==(const ClipboardData& lhs, const ClipboardData& rhs) {
  return lhs.text == rhs.text;
}

bool operator!=(const ClipboardData& lhs, const ClipboardData& rhs) {
  return lhs.text != rhs.text;
}

bool operator==(const HostData& lhs, const HostData& rhs) {
  return lhs.id == rhs.id && lhs.name == rhs.name && lhs.data == rhs.data;
}

bool operator!=(const HostData& lhs, const HostData& rhs) {
  return !operator==(lhs, rhs);
}

}  // namespace reclip

export template <>
struct std::formatter<reclip::HostPublicId> {
  auto format(reclip::HostPublicId p, format_context& ctx) {
    return format_to(ctx.out(), "{}", p.ToUnderlying());
  }
};
